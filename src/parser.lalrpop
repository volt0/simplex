use std::rc::Rc;

use crate::constant::Constant;
use crate::definition::Definition;
use crate::expressions::{Expression, ExpressionRef};
use crate::function::{Function, FunctionArgument, FunctionPayload};
use crate::module::Module;
use crate::statements::{CompoundStatement, Statement};
use crate::types::{FloatType, IntegerType, TypeSpec};
use crate::variable::Variable;

grammar;

// Module

pub Module: Module = {
    <defs:Definition*> => Module::new("__unknown__".into(), defs)
};

Definition: Definition = {
    <def:FunctionDefinition> => def,
};

// Functions

FunctionDefinition: Definition = {
    "fn" <name:Identifier> <function:Function> => Definition::define_function(name, function)
};

Function: Rc<Function> = {
    "(" <args:Comma<FunctionArgument>> ")" <return_type:TypeAnnotation?> <payload:FunctionPayload> => {
        Function::new(
            args,
            return_type.unwrap_or(TypeSpec::Void),
            payload,
        )
    }
}

FunctionArgument: Rc<FunctionArgument> = {
    <name:Identifier> <type_spec:TypeAnnotation> => FunctionArgument::new(name, type_spec)
}

FunctionPayload: FunctionPayload = {
    ";" => todo!(),
    <body:CompoundStatement> => FunctionPayload::Body(body),
}

// Statements

Statement: Statement = {
    <items:CompoundStatement> => Statement::Compound(items),
    "let" <var:VariableSignature> "=" <value:Expression> ";" => Statement::Let(Rc::new(Variable{name: var.0, value_type: var.1, value_init: value})),
    "var" <var:VariableSignature> "=" <value:Expression> ";" => todo!(),
    "if" <condition:Expression> <body:CompoundStatement> => todo!(),
    "while" <condition:Expression> <body:CompoundStatement> => todo!(),
    "for" "_" "=" <iterator:Expression> <body:CompoundStatement> => todo!(),
    "for" <var:VariableSignature> "=" <iterator:Expression> <body:CompoundStatement> => todo!(),
    "break" ";" => todo!(),
    "continue" ";" => todo!(),
    "return" ";" => todo!(),
    "return" <expression:Expression> ";" => Statement::Return(expression),
    <expression:Expression> ";" => todo!(),
}

CompoundStatement: CompoundStatement = {
    "{" <items:(<Statement>)*> "}" => CompoundStatement(items)
}

VariableSignature: (Rc<str>, Option<TypeSpec>) = {
    <name:Identifier> <type_spec:TypeAnnotation?> => (name, type_spec),
}

//// Expressions

PrimaryExpression: ExpressionRef = {
    <name:Identifier> => Box::new(Expression::Identifier(name)),
    <constant:Constant> => Box::new(Expression::Constant(constant)),
    "(" <expression:Expression> ")" => expression,
}

PostfixExpression: ExpressionRef = {
    <inner:PrimaryExpression> => inner,
    <subject:PostfixExpression> "(" <args:Comma<Expression>> ")" => todo!(),
    <subject:PostfixExpression> "[" <expression:Expression> "]" => todo!(),
    <subject:PostfixExpression> "." <name:Identifier> => todo!(),
}

UnaryExpression: ExpressionRef = {
    <inner:PostfixExpression> => inner,
    "+" <subject:UnaryExpression> => todo!(),
    "-" <subject:UnaryExpression> => todo!(),
    "~" <subject:UnaryExpression> => todo!(),
    "!" <subject:UnaryExpression> => todo!(),
}

RangeExpression: ExpressionRef = {
    <inner:UnaryExpression> => inner,
    <from:UnaryExpression> ".." <to:UnaryExpression> => todo!(),
}

CastExpression: ExpressionRef = {
    <inner:RangeExpression> => inner,
    <subject:CastExpression> "as" <typespec:TypeSpec> => todo!(),
}

MultiplicativeExpression: ExpressionRef = {
    <inner:CastExpression> => inner,
    <a:MultiplicativeExpression> "*" <b:CastExpression> => todo!(),
    <a:MultiplicativeExpression> "/" <b:CastExpression> => todo!(),
    <a:MultiplicativeExpression> "%" <b:CastExpression> => todo!(),
}

AdditiveExpression: ExpressionRef = {
    <inner:MultiplicativeExpression> => inner,
    <a:AdditiveExpression> "+" <b:MultiplicativeExpression> => Expression::new_add(a, b),
    <a:AdditiveExpression> "-" <b:MultiplicativeExpression> => todo!(),
}

ShiftExpression: ExpressionRef = {
    <inner:AdditiveExpression> => inner,
    <a:ShiftExpression> "<<" <b:AdditiveExpression> => todo!(),
    <a:ShiftExpression> ">>" <b:AdditiveExpression> => todo!(),
}

BitwiseAndExpression: ExpressionRef = {
    <inner:ShiftExpression> => inner,
    <a:BitwiseAndExpression> "&" <b:ShiftExpression> => todo!(),
}

BitwiseXorExpression: ExpressionRef = {
    <inner:BitwiseAndExpression> => inner,
    <a:BitwiseXorExpression> "^" <b:BitwiseAndExpression> => todo!(),
}

BitwiseOrExpression: ExpressionRef = {
    <inner:BitwiseXorExpression> => inner,
    <a:BitwiseOrExpression> "|" <b:BitwiseXorExpression> => todo!(),
}

ComparisonExpression: ExpressionRef = {
    <inner:BitwiseOrExpression> => inner,
    <a:ComparisonExpression> "<" <b:BitwiseOrExpression> => todo!(),
    <a:ComparisonExpression> ">" <b:BitwiseOrExpression> => todo!(),
    <a:ComparisonExpression> "<=" <b:BitwiseOrExpression> => todo!(),
    <a:ComparisonExpression> ">=" <b:BitwiseOrExpression> => todo!(),
    <a:ComparisonExpression> "==" <b:BitwiseOrExpression> => todo!(),
    <a:ComparisonExpression> "!=" <b:BitwiseOrExpression> => todo!(),
}

LogicalAndExpression: ExpressionRef = {
    <inner:ComparisonExpression> => inner,
    <a:LogicalAndExpression> "&&" <b:ComparisonExpression> => todo!(),
}

LogicalOrExpression: ExpressionRef = {
    <inner:LogicalAndExpression> => inner,
    <a:LogicalOrExpression> "||" <b:LogicalAndExpression> => todo!(),
}

ConditionalExpression: ExpressionRef = {
    <inner:LogicalOrExpression> => inner,
    <condition:LogicalOrExpression> "?" <case_a:ConditionalExpression> ":" <case_b:ConditionalExpression> => todo!(),
}

Expression: ExpressionRef = {
    <inner:ConditionalExpression> => inner,
}

// Types

TypeAnnotation: TypeSpec = {
    ":" <type_spec:TypeSpec> => type_spec
}

TypeSpec: TypeSpec = {
    "byte" => TypeSpec::SignedInteger(IntegerType::Byte),
    "short" => TypeSpec::SignedInteger(IntegerType::Short),
    "int" => TypeSpec::SignedInteger(IntegerType::Int),
    "long" => TypeSpec::SignedInteger(IntegerType::Long),
    "ubyte" => TypeSpec::UnsignedInteger(IntegerType::Byte),
    "ushort" => TypeSpec::UnsignedInteger(IntegerType::Short),
    "uint" => TypeSpec::UnsignedInteger(IntegerType::Int),
    "ulong" => TypeSpec::UnsignedInteger(IntegerType::Long),
    "float" => TypeSpec::Float(FloatType::Float),
    "double" => TypeSpec::Float(FloatType::Double),
    "bool" => TypeSpec::Boolean,
    "void" => TypeSpec::Void,
    <name:Identifier> => todo!(),
}

// Syntax base

Identifier: Rc<str> = <s:r"[_A-Za-z][_0-9A-Za-z]*"> => s.into();

Constant: Constant = {
    <value:IntegerConstant> => Constant::SignedInteger(IntegerType::Int, value as i64),
    <value:RealConstant> => Constant::Float(FloatType::Double, value),
    <value:StringConstant> => Constant::String(value),
    "true" => Constant::True,
    "false" => Constant::False,
    "void" => Constant::Void,
}

IntegerConstant: i64 = <s:r"[0-9]+"> => s.parse::<i64>().unwrap();
RealConstant: f64 = <s:r#"[0-9]+"."[0-9]*([Ee][+-]?[0-9]+)?[fFlL]?"#> => s.parse::<f64>().unwrap();
StringConstant: Rc<str> = <s:r#""(\\.|[^\\"])*""#> => s.into();

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
